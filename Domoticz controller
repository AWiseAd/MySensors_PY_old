#!/usr/bin/python
# MySensors-Domoticz controller - JSON and Hardcoded sensors
# uses local python dictionary DB for storage of sensors, values and updates

import time, calendar
import json
import serial
import requests
# import sqlite3 # for future DB update

###########################################
# Constants definition
###########################################
# MySensors Gateway serial, attached to USB0 
##########################################
S0_PORT = '/dev/ttyUSB0'	# specify absolute USB port of MySensors Gateway (defined in rules.d)
# Open serial port for S0 meter, timeout is 0 second = non-blocking
ser = serial.Serial(S0_PORT,115200, timeout=0)


###############################################
# Domoticz address & virtual meters/ variables
###############################################
DOMOTICZ_IP = "127.0.0.1"	# IP of domoticz metering system (on this system)
DOMOTICZ_PORT = "8080"		# Port number
DOMOTICZ_WU_THB = 36 		# WU Temperature, Humidity, Barometer, no real value here
DOMOTICZ_GEN_TEXT = 31		# Generic text message Domoticz (use for system message?)


# MySensors message en type definitions
# message structure = [1]node-id ; [2]child-sensor-id; [3]message-type; [4]ack; [5]sub-type; [6]payload\n
# Sensor message types
MS_PRESENTATION = 0 # Sent by a node when they present attached sensors. This is usually done in setup() at startup.
MS_SET = 1 		# This message is sent from or to a sensor when a sensor value should be updated
MS_REQ = 2		# Requests a variable value (usually from an actuator destined for controller).
MS_INTERNAL = 3 # This is a special internal message. See table below for the details, limited use here
MS_STREAM = 4 	# Used for OTA firmware updates (not used here)

# Sensor types and values
S_DOOR = 0 		# Door and window sensors
S_MOTION =	1	# Motion sensors
S_SMOKE	= 2		# Smoke sensor
S_LIGHT	= 3		# Light Actuator (on/off)
S_DIMMER = 4	# Dimmable device of some kind
S_COVER	= 5		# Window covers or shades
S_TEMP = 6		# Temperature sensor
S_HUM = 7		# Humidity sensor
S_BARO = 8		# Barometer sensor (Pressure)
S_WIND = 9		# Wind sensor
S_RAIN = 10		# Rain sensor
S_UV = 	11		# UV sensor
S_WEIGHT = 12	# Weight sensor for scales etc.
S_POWER = 13	# Power measuring device, like power meters
S_HEATER = 14	# Heater device
S_DISTANCE = 15	# Distance sensor
S_LIGHT_LEVEL = 16 # Light sensor
S_ARDUINO_NODE = 17	# Arduino node device
S_ARDUINO_RELAY = 18 # Arduino repeating node device
S_LOCK = 19		# Lock device
S_IR = 20		# Ir sender/receiver device
S_WATER = 21	# Water meter
S_AIR_QUALITY = 22	# Air quality sensor e.g. MQ-2
S_CUSTOM = 23	# Use this for custom sensors where no other fits.
S_DUST = 24		# Dust level sensor
S_SCENE_CONTROLLER = 25	# Scene controller device

# Sensor values
V_TEMP = 0 		# Temperature
V_HUM = 1		#Humidity
V_LIGHT	= 2 	# Light status. 0=off 1=on
V_DIMMER = 3 	# Dimmer value. 0-100%
V_PRESSURE = 4 	# Atmospheric Pressure
V_FORECAST =5 	# Weather forecast. One of "stable", "sunny", "cloudy", "unstable", "thunderstorm" or "unknown"
V_RAIN = 6 		# Amount of rain
V_RAINRATE = 7 	# Rate of rain
V_WIND = 8 		# Windspeed
V_GUST = 9 		# Gust
V_DIRECTION = 10 # Wind direction
V_UV = 11 		# UV light level
V_WEIGHT =12 	# Weight (for scales etc)
V_DISTANCE = 13 # Distance
V_IMPEDANCE = 14 # Impedance value
V_ARMED = 15 	# Armed status of a security sensor. 1=Armed, 0=Bypassed
V_TRIPPED = 16 	# Tripped status of a security sensor. 1=Tripped, 0=Untripped
V_WATT = 17		# Watt value for power meters
V_KWH = 18 		# Accumulated number of KWH for a power meter
V_SCENE_ON = 19 # Turn on a scene
V_SCENE_OFF = 20 # Turn of a scene
V_HEATER = 21 	# Mode of header. One of "Off", "HeatOn", "CoolOn", or "AutoChangeOver"
V_HEATER_SW = 22 # Heater switch power. 1=On, 0=Off
V_LIGHT_LEVEL = 23 # Light level. 0-100%
V_VAR1 = 24		# Custom value
V_VAR2 = 25		# Custom value
V_VAR3 = 26		# Custom value
V_VAR4 = 27		# Custom value
V_VAR5 = 28		# Custom value
V_UP = 29 		# Window covering. Up.
V_DOWN = 30 	# Window covering. Down.
V_STOP = 31 	# Window covering. Stop.
V_IR_SEND = 32 	# Send out an IR-command
V_IR_RECEIVE = 33 # This message contains a received IR-command
V_FLOW = 34		# Flow of water (in meter)
V_VOLUME = 35 	# Water volume
V_LOCK_STATUS = 36 # Set or get lock status. 1=Locked, 0=Unlocked
V_DUST_LEVEL = 37 # Dust level
V_VOLTAGE = 38 	# Voltage level
V_CURRENT = 39	# Current level

# Internal types & values
I_BATTERY_LEVEL = 0 # Use this to report the battery level (in percent 0-100).
I_TIME = 1 # Sensors can request the current time from the Controller using this message. The time will be reported as the seconds since 1970
I_VERSION = 2 # Sensors report their library version at startup using this message type
I_ID_REQUEST = 3 # Use this to request a unique node id from the controller.
I_ID_RESPONSE = 4 # Id response back to sensor. Payload contains sensor id.
I_INCLUSION_MODE = 5 # Start/stop inclusion mode of the Controller (1=start, 0=stop).
I_CONFIG = 6 # Config request from node. Reply with (M)etric or (I)mperal back to sensor.
I_FIND_PARENT = 7 # When a sensor starts up, it broadcast a search request to all neighbour nodes. They reply with a I_FIND_PARENT_RESPONSE.
I_FIND_PARENT_RESPONSE = 8 # Reply message type to I_FIND_PARENT request.
I_LOG_MESSAGE = 9 # Sent by the gateway to the Controller to trace-log a message
I_CHILDREN = 10 # A message that can be used to transfer child sensors (from EEPROM routing table) of a repeating node.
I_SKETCH_NAME = 11 # Optional sketch name that can be used to identify sensor in the Controller GUI
I_SKETCH_VERSION = 12 # Optional sketch version that can be reported to keep track of the version of sensor in the Controller GUI.
I_REBOOT = 13 # Used by OTA firmware updates. Request for node to reboot.
I_GATEWAY_READY	= 14 # Send by gateway to controller when startup is complete.


###########################################
# MySensors Database & routines
# database is hardcoded for now:
# - Domoticz id's assume "virtual" created devices
# - Reading is last value (13 is just placeholder..)
###########################################
Sensor_DB = [
			{"Node": 1, "Child": 1, "Type": S_MOTION,"Domoticz_id": 0, "Reading": 12, "LastUpdate": None}, # repeater 1 - motion
			{"Node": 2, "Child": 1, "Type": S_MOTION,"Domoticz_id": 0, "Reading": 12, "LastUpdate": None}, # repeater - motion
			{"Node": 2, "Child": 2, "Type": S_BARO,"Domoticz_id": 0, "Reading": 13, "LastUpdate": None}, # repeater - baro
			{"Node": 2, "Child": 3, "Type": S_TEMP,"Domoticz_id": 26, "Reading": 13, "LastUpdate": None}, # repeater - temp (baro)
			{"Node": 2, "Child": 10, "Type": S_CUSTOM,"Domoticz_id": 31, "Reading": 13, "LastUpdate": None}, # repeater - LCD message 1
			{"Node": 2, "Child": 11, "Type": S_CUSTOM,"Domoticz_id": 32, "Reading": 13, "LastUpdate": None}, # repeater - LCD message 2
			{"Node": 4, "Child": 1, "Type": S_MOTION,"Domoticz_id": 16, "Reading": 12, "LastUpdate": None}, # achtertuin - motion
			{"Node": 4, "Child": 2, "Type": S_BARO,"Domoticz_id": 43, "Reading": 13, "LastUpdate": None}, # achtertuin - baro
			{"Node": 4, "Child": 3, "Type": S_TEMP,"Domoticz_id": 8, "Reading": 13, "LastUpdate": None}, # achtertuin - temp(baro)
			{"Node": 4, "Child": 4, "Type": S_HUM,"Domoticz_id": 0, "Reading": 13, "LastUpdate": None}, # achtertuin - humidity
			{"Node": 4, "Child": 5, "Type": S_TEMP,"Domoticz_id": 0, "Reading": 13, "LastUpdate": None}, # achtertuin - temperature (humidity)
			{"Node": 4, "Child": 6, "Type": S_LIGHT,"Domoticz_id": 12, "Reading": 13, "LastUpdate": None}, # achtertuin - light
			{"Node": 5, "Child": 1, "Type": S_MOTION,"Domoticz_id": 17, "Reading": 12, "LastUpdate": None}, # voortuin - motion
			{"Node": 5, "Child": 4, "Type": S_HUM,"Domoticz_id": 30, "Reading": 13, "LastUpdate": None}, # voortuin - humidity (DHT)
			{"Node": 5, "Child": 5, "Type": S_TEMP,"Domoticz_id": 24, "Reading": 13, "LastUpdate": None}, # voortuin - temperature (DHT, humidity)
			{"Node": 5, "Child": 6, "Type": S_LIGHT,"Domoticz_id": 28, "Reading": 13, "LastUpdate": None}, # voortuin - light
			{"Node": 6, "Child": 1, "Type": S_MOTION,"Domoticz_id": 18, "Reading": 12, "LastUpdate": None}, # woonkamer - motion
			{"Node": 6, "Child": 2, "Type": S_BARO,"Domoticz_id": 0, "Reading": 13, "LastUpdate": None}, # woonkamer- baro
			{"Node": 6, "Child": 3, "Type": S_TEMP,"Domoticz_id": 0, "Reading": 13, "LastUpdate": None}, # woonkamer - temp (baro)
			{"Node": 6, "Child": 4, "Type": S_HUM,"Domoticz_id": 45, "Reading": 13, "LastUpdate": None}, # woonkamer - humidity (DHT)
			{"Node": 6, "Child": 5, "Type": S_TEMP,"Domoticz_id": 46, "Reading": 13, "LastUpdate": None}, # woonkamer - temperature (DHT, humidity)
			{"Node": 6, "Child": 6, "Type": S_LIGHT,"Domoticz_id": 44, "Reading": 13, "LastUpdate": None}, # woonkamer - light
			{"Node": 7, "Child": 1, "Type": S_MOTION,"Domoticz_id": 0, "Reading": 12, "LastUpdate": None}, # dak - motion
			{"Node": 7, "Child": 2, "Type": S_BARO,"Domoticz_id": 42, "Reading": 13, "LastUpdate": None}, # dak - baro
			{"Node": 7, "Child": 3, "Type": S_TEMP,"Domoticz_id": 23, "Reading": 13, "LastUpdate": None}, # dak - temp (baro)
			{"Node": 7, "Child": 4, "Type": S_HUM,"Domoticz_id": 19, "Reading": 13, "LastUpdate": None}, # dak - humidity (DHT)
			{"Node": 7, "Child": 5, "Type": S_TEMP,"Domoticz_id": 20, "Reading": 13, "LastUpdate": None}, # dak - temperature (DHT, humidity)
			{"Node": 7, "Child": 6, "Type": S_LIGHT,"Domoticz_id": 21, "Reading": 13, "LastUpdate": None}, # dak - light
			{"Node": 8, "Child": 1, "Type": S_MOTION,"Domoticz_id": 0, "Reading": 13, "LastUpdate": None}, # multi- motion
			{"Node": 8, "Child": 2, "Type": S_BARO,"Domoticz_id": 0, "Reading": 13, "LastUpdate": None}, # multi- baro
			{"Node": 8, "Child": 3, "Type": S_TEMP,"Domoticz_id": 15, "Reading": 13, "LastUpdate": None}, # multi- temp2
			{"Node": 8, "Child": 4, "Type": S_HUM,"Domoticz_id": 14, "Reading": 13, "LastUpdate": None}, # multi- humidity
			{"Node": 8, "Child": 5, "Type": S_TEMP,"Domoticz_id": 6, "Reading": 13, "LastUpdate": None}, # multi- temp
			{"Node": 8, "Child": 6, "Type": S_LIGHT,"Domoticz_id": 11, "Reading": 13, "LastUpdate": None}, # multi- light
			{"Node": 8, "Child": 10, "Type": S_CUSTOM,"Domoticz_id": 33, "Reading": 13, "LastUpdate": None}, # multi- LCD 1
			{"Node": 8, "Child": 11, "Type": S_CUSTOM,"Domoticz_id": 34, "Reading": 13, "LastUpdate": None}, # multi- LCD 2
			{"Node": 13, "Child": 1, "Type": S_COVER,"Domoticz_id": 47, "Reading": 13, "LastUpdate": None}, # Curtain control
			{"Node": 91, "Child": 2, "Type": S_TEMP,"Domoticz_id": 0, "Reading": 13, "LastUpdate": None}, # repeater
			{"Node": 92, "Child": 3, "Type": S_TEMP,"Domoticz_id": 0, "Reading": 14, "LastUpdate": None} # repeater
			]

			
## Check if sensor in DB and return dictionary
def DB_get_sensor(MS_node, MS_child):
# returns None or full dict
    return [item for item in Sensor_DB if (item['Node'] == int(MS_node)) and (item['Child'] == int(MS_child))]

## Check if dcz device in DB and return dictionary
def DB_get_dczdev(DCZ_dev):
# returns None or full dict
    return [item for item in Sensor_DB if (item['Domoticz_id'] == int(DCZ_dev))]
	
## replace reading in DB for MS device
## Sensor_DB[0]["Domoticz_id"] = 999 # i.e. locate the sensor and replace value
def DB_replace_reading(MS_node, MS_child, new_value): # only call if node & sensor present!!
# input node & sensor = unique key
# new_reading = reading to be replaced 
    for p in enumerate(Sensor_DB): # enumerates the dictionary items so that they can be used as index
        if (Sensor_DB[p[0]]['Node'] == int(MS_node)) and (Sensor_DB[p[0]]['Child'] == int(MS_child)):
			Sensor_DB[p[0]]['Reading'] = new_value
			Sensor_DB[p[0]]['LastUpdate'] = time.strftime("%F %T") # set to current time
			return

## replace reading in DB for DCZ device
## Sensor_DB[0]["Domoticz_id"] = 999 # i.e. locate the sensor and replace value
def DB_replace_reading_dcz(DCZ_dev, new_value): # only call if present!!
# input dcz_dev = unique key
# new_reading = reading to be replaced 
    for p in enumerate(Sensor_DB): # enumerates the dictionary items so that they can be used as index
        if (Sensor_DB[p[0]]['Domoticz_id'] == int(DCZ_dev)):
			Sensor_DB[p[0]]['Reading'] = new_value
			Sensor_DB[p[0]]['LastUpdate'] = time.strftime("%F %T") # set to current time
			return

			

##########################################
# -- Domoticz routines
##########################################
# Open Domoticz json url and get response
def dcz_request(dcz_json):
	try:
		request = requests.get('http://' + DOMOTICZ_IP + ':' + DOMOTICZ_PORT + dcz_json)
		#print(request.text)
		r = json.loads(request.text)
		#print(r)
	except requests.exceptions.ConnectionError as e:    # Check connection error in correct syntax
		print(time.strftime("%c") + " Call to Domoticz failed, not available.")
		print(e)
		r = "Error"
	except requests.exceptions.RequestException as e:    # Catch other exceptions
		print(time.strftime("%c") + " Call to Domoticz failed.")
		print(e)
		r = "Error"
	return (r)
	
# read values from domoticz device (json)
# input = variable index
# return = variable with attributes	
def read_domoticz_dev(dcz_var_idx):
	dcz_command = '/json.htm?type=devices&rid='+str(dcz_var_idx)
	#print(dcz_command)
	# load and convert from json in one line
	var_json=dcz_request(dcz_command)
	try:
		result = var_json["result"][0]
	except (ValueError, KeyError, TypeError):
		print(time.strftime("%c") + " Error receiving Domoticz data")
		result = "Error"
	return(result)

# read switches from domoticz (json)
# input = none
# return = variables with attributes	
def read_domoticz_switches():
	dcz_command = '/json.htm?type=devices&filter=light&used=true'
	# load and convert from json in one line
	var_json=dcz_request(dcz_command)
	try:
		result = var_json["result"]
	except (ValueError, KeyError, TypeError):
		print(time.strftime("%c") + " Error receiving Domoticz data")
		result = "Error"
	return(result)	

# send values to domoticz usage virtual device (json)
# input = virtual device, (single) value,
# return = domoticz message (json)
# needs to adapt to Sensor type, limited number of sensors implemented, Domoticz "virtual devices" is default
def send_domoticz_dev(dcz_dev, dev_type, dev_value):
	if int(dev_type) == V_HUM: # humidity needs nvalue = Humidity & svalue = 0..3 (normal, comfortable, dry, wet)
		dcz_command= '/json.htm?type=command&param=udevice&idx=' + str(dcz_dev) + '&nvalue=' + str(dev_value) + '&svalue=1'
		# print(dcz_command)
	elif int(dev_type) == V_PRESSURE: # pressure is sent in combined Temp hum baro device (temp & hum set to 0 (domoticz has no separate barometric pressure)
		dcz_command= '/json.htm?type=command&param=udevice&idx=' + str(dcz_dev) + '&nvalue=0&svalue=0;0;0;' + str(dev_value) + ';0' 
		#print("DCZ-json  ", dcz_command)
	elif int(dev_type) == V_TRIPPED: # motion sensor, set domoticz switch accordingly
		#/json.htm?type=command&param=switchlight&idx=&switchcmd=&level=0
		# print("motion sensor: ", dev_value)
		if str(dev_value) == "1": # switch = on
			dcz_command= '/json.htm?type=command&param=switchlight&idx=' + str(dcz_dev) + '&switchcmd=On' + '&level=0'
		else: # str(dev_value) == "0"
			dcz_command= '/json.htm?type=command&param=switchlight&idx=' + str(dcz_dev) + '&switchcmd=Off' + '&level=0'
	else: # no specific command, assume default values (or should we do nothing to avoid crashes?)
		dcz_command= '/json.htm?type=command&param=udevice&idx=' + str(dcz_dev) + '&nvalue=0&svalue=' + str(dev_value)
	result = dcz_request(dcz_command)
	#print(dcz_command)
	return(result)
	
def get_dcz_temp_hum_baro(sensor): # not really needed here, for testing only
	# get sensor value in array, without units
	# Temp - Hum - Baro 
	dcz_dev_r = read_domoticz_dev( sensor ) # temperature, humidity, baro
	# split sensor data in elements with units and print individual
	# remove blanks between data and unit
	print(dcz_dev_r["Data"])
	return_array = []
	for sensor_data in dcz_dev_r["Data"].split(', '): # ", " between return values
		return_array.append(sensor_data.split(' ')[0]) # remove units
	return(return_array)
	
#############################################################
# Main Mysensors routines
###############################################################
# build MySensors telegram (message)
def MS_make_telegram(MS_node, MS_child, MS_type, MS_ack, MS_subtype, MS_payload):
	# builds telegram for sending to MySensors network
	# takes strings as argument
	telegram = ";".join((str(MS_node), str(MS_child), str(MS_type), str(MS_ack), str(MS_subtype), str(MS_payload)));
	print(telegram)
	return (telegram + "\n") # newline is needed to complete telegram

# just for debug and test, print the node names and current attributes	
def print_node_info(MS_node, MS_child, MS_type, MS_subtype, MS_payload):
	if MS_node == "0":
		# print("Gateway")
		MS_gateway = 1
	elif MS_node == "1":
		print("Repeater power", MS_node, MS_child, MS_type, MS_subtype, MS_payload)
	elif MS_node == "2":
		print("Repeater Overloop", MS_node, MS_child, MS_type, MS_subtype, MS_payload)
	elif MS_node == "3":
		print("Aanbouw", MS_node, MS_child, MS_type, MS_subtype, MS_payload)
	elif MS_node == "4":
		print("Achtertuin", MS_node, MS_child, MS_type, MS_subtype, MS_payload)
	elif MS_node == "5":
		print("Voortuin", MS_node, MS_child, MS_type, MS_subtype, MS_payload)
	elif MS_node == "6":
		print("Woonkamer", MS_node, MS_child, MS_type, MS_subtype, MS_payload)
	elif MS_node == "7":
		print("Dak", MS_node, MS_child, MS_type, MS_subtype, MS_payload)
	elif MS_node == "8":
		print("Multi", MS_node, MS_child, MS_type, MS_subtype, MS_payload)
	elif MS_node == "9":
		print("Multi sensor", MS_node, MS_child, MS_type, MS_subtype, MS_payload)
	elif MS_node == "13":
		print("Curtain controller", MS_node, MS_child, MS_type, MS_subtype, MS_payload)
	elif MS_node == "90":
		print("Repeater", MS_node, MS_child, MS_type, MS_subtype, MS_payload)
	else:
		print("Sensor not registred")
	return

# just for debug and test, print the node types, attributes and values with unit	
def print_node_type(MS_node, MS_child, MS_type, MS_subtype, MS_payload):
	case = int(MS_subtype)
	if case == V_TEMP:
		print("Temperature: ", MS_node, MS_child, MS_payload + "C")
	elif case == V_HUM:
		print("Humidity:    ", MS_node, MS_child, MS_payload + "%")
	elif case == V_PRESSURE:
		print("Pressure:    ", MS_node, MS_child, MS_payload + "hPa")
	elif case == V_LIGHT:
		print("Light:       ", MS_node, MS_child, MS_payload +"Lux")
	elif case == V_VAR1:
		print("Variable1    ", MS_node, MS_child, MS_payload +" Time")
	elif case == V_TRIPPED:
		print("Motion       ", MS_node, MS_child, MS_payload +" On/off")
	# else ignore
	return

	
# Process the MySensors messages according to type	
# input = content of telegram
# global = Sensor_DB
def process_MS_message(	MS_node, MS_child, MS_type, MS_subtype, MS_payload):
	if int(MS_type) == MS_SET :
		# print("Set sensor")
		# debug: print_node_type(MS_node, MS_child, MS_type, MS_subtype, MS_payload)
		DB_result = DB_get_sensor(MS_node, MS_child)
		# print("Sensor  ", Sensor)
		if DB_result != []: # if found in database (if not Sensor should be added)
			Sensor = DB_result[0] # database can return many results, use only first one for now
			if (Sensor['Domoticz_id']) != 0: # if domoticz_id present update domoticz
				send_domoticz_dev(Sensor['Domoticz_id'], MS_subtype, MS_payload)
		# update database and LastUpdate
		DB_replace_reading(MS_node, MS_child, MS_payload)
	elif int(MS_type) == MS_REQ:
		# Sensor requested response
		# print("Request")
		DB_result = DB_get_sensor(MS_node, MS_child) # Determine message type from database
		if DB_result != []: # if found in database (if not, the Sensor should be added manually for now)
			# if there is a domoticz_id present then get message from Domoticz
			Sensor = DB_result[0] # database can return many results, use only first one for now
			# print("Req message, send response now")
			if (Sensor['Domoticz_id']) != 0: # if domoticz_id present get and send domoticz "Data" Value
				#print("Domoticz sensor", Sensor['Domoticz_id'], Sensor['Domoticz_id'])
				Message = read_domoticz_dev(Sensor['Domoticz_id'])['Data']
			else: # no domoticz_id present, send internal message (environment, status)
				# should check... if int(MS_subtype) == V_VAR1: # LCD message telegram (custom)
				t_h_b = get_dcz_temp_hum_baro(DOMOTICZ_WU_THB) # WU, returns three values without unit
				Message = ('{}C {}% {}hP'.format(t_h_b[0], t_h_b[1], t_h_b[2]))
			telegram = MS_make_telegram(MS_node, MS_child, str(MS_SET), "0", str(MS_subtype), Message)
			#print(telegram)
			ser.write(telegram)
			DB_replace_reading(MS_node, MS_child, MS_payload) # always update readings
		# else ignore and do nothing
	elif int(MS_type) == MS_INTERNAL:
		if int(MS_subtype) == I_TIME: # Time telegram
			print("time request, should send response now")
			# should be epoch local... no good way to determine yet
			time_telegram = MS_make_telegram(MS_node,"255", str(MS_INTERNAL), "0", MS_subtype, str(int(calendar.timegm(time.localtime()))))
			print(time_telegram)
			ser.write(time_telegram)
			# else ignore and do nothing
	elif int(MS_type) == MS_PRESENTATION:
		print("Presentation")
		print_node_info(MS_node, MS_child, MS_type, MS_subtype, MS_payload)
	else:
		print("No action for this message")

## Poll status of switch items in domoticz and update corresponding values 
## take appropriate action, i.e. update sensor 
## Sensor_DB[0]["Domoticz_id"] =  # i.e. locate the sensor and replace value
def DB_poll_dcz(): # 
# input global Sensor_DB, lastpoll (last update)
# output = status 
	global lastpoll # last poll (in LastUpdate format)
	#print("Database sync")
	dcz_switches = read_domoticz_switches() # read the switch values from domoticz
	for dcz_switch in dcz_switches:
		if (dcz_switch['LastUpdate'] > 0): #lastpoll): # disabled: check of updates only if change since lastpoll (need to be aware of delays.., )
			DB_result = DB_get_dczdev(dcz_switch['idx']) # check if dcz sensor is in database
			if DB_result != []: # if found in database (if not, nothing for now)
				Sensor = DB_result[0] # database can return many results, use only first one for now
				if (dcz_switch['LastUpdate'] > Sensor['LastUpdate']): # action and update if change from last time
					# replace reading in DB and update LastUpdate, reading is level (opposed to on/off)
					on_values = ["On", "Up", "Open"]
					off_values = ["Off", "Down", "Closed"]
					dcz_value =  dcz_switch['Data'] # domoticz response value
					if (True in [True for match in on_values if match in dcz_value]): # if on, 100%
						sensor_value = 100
					elif (True in [True for match in off_values if match in dcz_value]): # if off, 0%
						sensor_value = 0
					else: # otherwiss use dimmer level
						sensor_value = dcz_switch['Level']
					DB_replace_reading_dcz(dcz_switch['idx'], sensor_value)
					#Debug: print("Switch present in DB, status updated", Sensor)
					telegram = MS_make_telegram(Sensor['Node'],Sensor['Child'], MS_SET, 1, V_DIMMER, sensor_value)
					#print(telegram)
					ser.write(telegram)
	lastpoll = time.strftime("%F %T") # update the global poll variable
	return

	
#### main loop ###
# print start
# get MySensors telegram(message), non-blocking and take action
# check if updates in Domoticz switches and take action 
# 
CurrentTime =  time.strftime("%F %T") 	# for use in update
print(CurrentTime + " Start")
lastupdate = time.time() 				# timer value for per xx seconds update
lastpoll_t = lastupdate					# timer value for per xx seconds polling of domoticz
lastpoll = CurrentTime 					# sets the last domoticz database poll, checks to for changes
loop_count = 0 							# just for debug
while 1 :
	# Loop: read lines from serial port, decode and send to Domoticz
	try:
		# set delay variable
		now = time.time()
		# first read messages
		MySensors_telegram = str(ser.readline()).strip()
		if (MySensors_telegram <> ""):
			print(MySensors_telegram)
			# all values are string type
			MS_node, MS_child, MS_type, MS_ack, MS_subtype, MS_payload = MySensors_telegram.split(";")
			# print_node_info(MS_node, MS_child, MS_type, MS_subtype, MS_payload)
			process_MS_message(	MS_node, MS_child, MS_type, MS_subtype, MS_payload) # proces the message and take action
		
		# sync DB with domoticz, test
		if (now - lastpoll_t > 1): # once every 1 second
			DB_poll_dcz()
			lastpoll_t = now
		
		# delayed send messages only for debug and testing
		if (now - lastupdate > 30): # once every sixty seconds
			# create messages
			Message1 = time.strftime("%c") # environment
			Message2 = "System:  " # status
			lastupdate = now
			loop_count += 1
			
		# sleep a little to avoid CPU max.load
		time.sleep(0.3) 
	except (ValueError, KeyError, TypeError), e:
		print("Wrong/No input from MySensors gateway", e)
